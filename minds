Rx в современной мобильной разработке. Есть ли смысл?

В докладе речь пойдет о целесообразности использования ФРП (Functional Reactive Programming) в современной мобильной разработке на примере RxSwift под iOS. Еще год назад мне казалось, что невозможно писать код без использования Rx, а все самописные велосипеды, призванные в очередной раз реализовать паттерн Observer  - от лукавого. Во всех проектах, в которых мне довелось поучаствовать, в числе которых две версии Яндекс.Карт под Windows Phone и iOS, Rx стал одной из главных библиотек, насквозь пронизывающей все слои приложения. В последнее время мое отношение к Rx стало гораздо более прагматичным в силу ряда причин, о которых я расскажу в докладе. Цель моего доклада - поглубже посмотреть на устройство одного из самых популярных фреймворков для ФРП под iOS - RxSwift и на его примере показать, что Rx как и любой инструмент - это лишь удобный способ решения определенного спектра задач. Мы поговорим о best practices при использовании Rx, тонкостях использования различных компонентов любого современного Rx фреймворка, таких как Subject, Scheduler, Trait и других, рассмотрим способы тестирования сложных time-dependent фич, коснемся вопросов о контрактах Rx и многом другом, а главное, попытаемся понять, помогут ли все эти знания сделать наш проект более понятным, поддерживаемым и bug-free

Вводная часть будет посвящена описанию  Rx для тех кто не в теме:
- Откуда вообще взялся FRP. Про push/pull модель. Тут расскажу, что FRP - реализация push модели, где на разработчике в идеальном мире лежит задача обрабатывать потоки событий (пользовательский ввод, нотификации от системы, ответы от backend/БД etc). Под обрабатывать понимается - выполнять различные трансформации над ними (merge, filter, map, etc + выполнять side-effect’ы)
- Кратко поговорим об отличии от Feature’ов, Task’ов (C#), completion’ов (callback’ов) в чистом виде. Конкретно: Более развитая концепция с удобным набором операторов для преобразования, например, из completion’ов в Observable’ы… упрощенной работой с concurrency, единообразная реализация на разных ЯП (не без проблем конечно)
- Пару слов о дуализме Iterable и Observable. Кратко о том, что за всем этим лежит не абы что, а целая математика с доказательствами и т.п.
- Какие проблемы был призван решать (были Task’и в C# и даже async/await но таск это getData() -> T асинхронный, а вот как сделать getData() -> IEnumerable<T> асинхронный?
- Как устроен - основные понятия (Main Types, Operators, Subjects, Schedulers, Traits)… Тут для тех,  кто не в теме кратко расскажу устройство среднестатистического фреймворка реализующего Reactive Extensions. Для чего нужно все это (Scheduler’s - абстракция над  многопоточностью, Subjects - когда прям не знаешь как из входных стримов получить выходные или когда нужно какую-нибудь магию с сайдэффектами сделать или когда прям нужен стейт здесь и сейчас и без него никак… короче для слабых=), Traits - когда ты знаешь, что это ну вот прям точно Observable, например из одного ивента, то можно Single заюзать и дальше проще на него подписываться не обрабатывая onComplete и так далее про каждый)

Основная часть: Постараюсь ответить на ряд распространенных вопросов, которые возникают при желании начать использовать. Потом расположу упорядоченно. Пока накидал просто в кучу.
- Где и почему чаще всего пытаются применять (UI, сеть/БД). Для Networking - уход от callback hell (как же без него) плюс чейнинг операций с переходом на разные “потоки”. В UI - для простого байндинга к textField’ам и т.п. В Core части (Business logic) для декларативного описания трансформаций над входными данными с возможностью тестировать, например, time-dependent фичи
- Что лучше - везде или изолированно использовать в коде. Здесь расскажу, что Rx умеет “прорастать” из слоя Networking в слой Business Logic, к которому потом просто забиндить UI =) Тут расскажу, что лучше юзать там, где есть уверенность, что все работает хорошо и без багов (то есть протестированно (thanks cap!). То есть юзать можно хоть везде, хоть только в одном классе, главное тестировать и правильно входить/выходить из Rx парадигмы
- Извечные проблемы Rx: 
    - Стрельнет ли стрим при подписке синхронно? Неправильное понимание типа Observable (как и к листенерам в джаве, NSNotificationCenter и любому другому обзерваблу вопрос, получу ли значение при подписке). Надо ли startWith, а если код с UIView.animate? Да - сложно. 2 выхода - конвенции и правильный путь, чтоб потом не думать, а чего это тут стрельнуло? Тут плавно переходим к контрактам Observable (>=0 событий .onNext, onError/onCompleted, после чего не может быть onNext). Если работать c Observable не ожидая от него ничего большего (например вызывать в нужных местах startWith, если точно нужно начальное состояние и т.п.), то код будет сложнее, но правильнее. Но главное, что он будет более поддерживаемым, так как о ваших ожиданиях от Observable’а чего-то большего, чем его контракт не знает никто, кроме вас.
    - Где нужно шедулить (subscribeOn/observeOn) - Ответ: в самом ближнем к UI слое и не раньше. Клиент должен решать на каком “потоке” выполнить тот или иной код. Но в таком случае бывает сложнее писать тесты (иногда, особенно, если мало шедулинга в приложении, можно инкапсулировать шедулинг на другой “поток” и обратно на mainThread за протоколом и подменить его в тесте не запариваясь с мокированием и передачей TestScheduler в твой объект в тесте)
    - Как получить текущее значение как var someStreamCurrentValue: T { get … }. Такой необходимости при написании на “чистом true Rx” просто не должно быть. В тестах - TestObserver нам скажет какие события он поймал. В коде используем CombineLatest, Merge, WithLatestFrom и т д. Но тут возникает проблема, что тот код, который бы при наличии стейта выглядел бы синхронно, например вызов service.fetchItems в методе onButtonTap, превращается в buttonTaps.flatMapLatest { service.fetchItems }… И это может отпугивать.  
    - А что же все такое горячий Observable vs холодный… а если к горячему добавить startWith? А как узнать это по интерфейсу? Никак - поэтому нужны тесты… А как тестировать Rx? А вот тут то мы к шедулерам вернемся и поговорим о том, что лучшего способа тестировать разные longRunning/time-dependent фичи просто не сущ-ет (ты же не хочешь чтобы тест ждал 45 минут, когда ты заэмитишь событие) Расскажу как это делать на примере. Еще тут расскажу про проблему многократного выполнения кода “долгого” или повторно хождения в сеть, из-за чего могут появиться неконсистентность . Например 2 разных ответа от сервиса при запросе в 2-х последовательно идущих подписках - например 2 проперти класса подписываются на один и тот-же стрим. Решение: ты даже делаешь один стрим из которого торчат 2 значения вместе и делаешь 2 подписки, коммитишь и идешь пить кофе, а потом баг переоткрывают, потому что подписку надо share’ить. И тут хорошее время для небольшое рассказ про Traits (Driver, Single, Completable). Что они помогают решить такие проблемы, но вводят новые сущности с новыми контрактами и необходимостью жить одновременно с Driver’ом и Observable’ом, торчащими из объектов, которые твой класс получил в init’е. Правильное решение - использовать Driver’ы только для слоя перед UI (ViewModel).
    - Огромные стектрейсы. Ответ - вас они не касаются в 99 процентов случаев =) Обычно дебаг занимает при написании на Rx меньше времени, поэтому потратить 2 секунды лишних на поиск твоего callback’а в цепочке их внутренних вызовов Rx не очень кажется сложным. 
    - Частные проблемы в iOS (список будет расширен):
        - Проблема: lazy или computed должен быть стрим в проперте и должно ли это что-то менять? Тут скажу, что Observable это структура и все решает подписка. Все зависит от того, какой у тебя observable. Если ты хочешь например выдавать наружу shareReplayLatestWhileConnected, то var или lazy var имеет значение.
        - Немного моментов отдельных (иммутабельность, лайфтайм подписок, чистые функции и т д) Все аргументы событий должны быть иммутабельны, а функции без сайде эффектов. Где хранятся observer’ы и нужно ли диспозить disposable… а сохранять его? Тут кратко про то, как устроены ресурсы в Rx, что их можно отслеживать, что для iOS ввели понятие DisposeBag которые сам все задиспозит при deinit’е. В зависимости от времени можно посмотреть кто хранить observer’ов и нужно ли сохранять стримы (Observable’ы). Тут кстати самому нужно покапать). Думаю рассмотреть это на примере типа: как быть, если класс в подписке на стрим из объекта переданного в int’е например, применяет map в котором нужно вызывать self.someManager.translateTextToRussian($0). Нужно ли делать [weak self]…, а в onNext и так далее.

Из этих проблем вытекает с одной стороны, что везде должны быть обзерваблы без сабджектов, но тогда СЛОЖНА!!! И нельзя Стейт получить и при протаскивании через все слои постоянно думаешь что когда стрельнет (заэмитится) и на каком шедулере выполняется (редко чаще всего) потому что код не обрабатывает все ситуации и не все протестировано… Как быть? Ответ: Прагматично… в зависимости от задачи, можно юзать конвенции themeUpdates(withCurrentValue…) -> Observable<…>, можно забить на то, что из протоколов должны торчать только Observable, а сделать чтоб торчали BehaviorRelay’и то есть фактически классы из имплементаций протоколов, но это прям совсем зашквар) и еще некоторые рекомендации будут, например как уйти от Subject’ов

- Как переходить из мира Rx в мир completion’ов и обратно (бонус как сделать для listener’ов как в джаве). Тут про RxAdapter’ы можно сказать… что типо если в задаче у нас есть протокол с методами с completion’ами или с листенером, а нам надо применять сложные манипуляции со стримами из этих событий, то можно делать RxAdapter’ы, из которых вместо completion’ов торчат стримы, и работать с ними соот-но применяя Observable.create { observer -> Disposable in  } или Observable.fromAsync
- Чутка про UI - кастомные extension’ы в UIView (UILabel.rx…) например MyView.rx.state.bind(to: viewModel.state)
- Если про Яндекс.Карты поговорить, то рассказать, что вот у нас шаблоним по MVVM с блэкджеком и у нас у ViewModel часто есть Observable<State>, где State - enum с Associated Value и вьюха получается простой. Одна проблема что ViewModel как бы знает про UIKit, ибо UIColor, UIImage etc… но на практике клюшки пилятся оч быстро. А вот все проблемы о которых я рассказывал так и не решены до сих пор (пилим на сабджектах =)
- Проблема разделения стримов на части, когда у тебя завершился поиск с SearchEventArgs структурой из массива риз-тов и метадаты, а ты делаешь 2 стрима - results и metadata… Так делать не ннада. В общем как вообще в итоге проще решать задачу - сводить все к одному монстростриму с событием из кучи полей или как-то еще… Тут расскажу, что у меня был опыт со сложной задачкой в Картах на Windows, где мне и пришлось переписывать несколько раз (то так, то сяк). В итоге, если делить на маленькие стримы, то получается, что их потом нужно комбинировать там, где на самом деле это одно событие… в случае же с моностримом все вроде ок, но много лишних данных, и, если ты в него “поддерживаешь” дополнительные данные, то начинаются проблемы с тем, что ты начинаешь думать, когда же он в итоге заэмитит значение и функции для работы с Event’ом такого стрима получают на вход много лишних данных (может спасти разделение как в Redux - стейта на подстейты)
- Какой набор операторов реально используется? Зависит от задачи и расскажу про те что сам чаще всего использую (можно опустить этот пункт). Можно здесь еще про то, как свой оператор написать рассказать (но это не быстро и хардкора пункт, ибо надо в кишки Rx лезть - Sink, Source и т д)
- Про правила хорошего тона, без которых никак, например 
    - есть метод func loadImage() -> Observable<Result<UIImage, Error>>. Пока не подписался, не должен запускаться код загрузки
    - пробрасывайте ошибки ваших методов с completion’ами в ошибки onError в Rx. Тогда можно будет наворачивать логику retry и “проглатывать” где нужно. Не стоит злоупотреблять комментариями вроде “Этот стрим не кидает ошибок”… но к сожалению, мне лично, очень не хватает ErrorLessObservable… И тут можно сказать, что вы можете написать свой Trait!=) Но это тоже если будет время на hardcore part. Я сам не писал, но кажется, что смог бы)

Tips: 

http://reactivex.io/documentation/operators.html#tree - Operators Decision tree =)

Как посмотреть, есть ли траблы с ресурсами (подписками) aka memory leaks в RxSwift:
* navigate to your screen and use it
* navigate back
* observe initial resource count
* navigate second time to your screen and use it
* navigate back
* observe final resource count

Добавляй share на UI слое (https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md#sharing-subscription)

Выводы:

Вся война и борьба с rx это попытка выйти из основного определения обзервабла чтобы было проще код писать. Поэтому используйте где уверены, так проще. Например scrollViewDidScroll стрельнет ли начальным контентоффсетом
Бест практисес - источников стримов должно быть мало - запросы, нотификации системы и события UI. Пользуйтесь по минимум платформозасимимыми трейтами. Логика на несколько платформ должна быть описана дефолтными штуками которые есть в любой имплементации rx. 


Дополнения: 
- Вообще внедрять rx, если вы все таки решились стоит со слоя UI, ибо иначе он прорастет и рефакторить сразу надо будет много
- Явное лучше неявного (на этом основан например DI) поэтому шедулеры (или их провайдеры) в идеальном коде написанному например по вайперу будут внедряться в один тип сущностей

Задачи: 
- Написать кастомный Trait
- Написать кастомный оператор

Написать пример с amb (lowQuality.amd(highqualityShare).concat(highQualityShared).distinctUntil
